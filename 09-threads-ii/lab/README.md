# Многонишково програмиране (част II)

## Сноуборд сезон

Ще разработим софтуер за продажба на сноуборд/ски карти в зимен курорт.

В нашата система

- се използва каса (гише, терминал), където се продават карти
- пистите имат максимален капацитет от 1000 сноубордиста, т.е. в едновременно обращение не може да иа повече от 1000 карти. При опит да се купят повече карти, трябва да се хвърли `java.lang.IllegalStateException`
- всяко каса пази данните за всички издадени карти - име на ползвател и дата/час на издаване.

Възможните операции на каса са

- закупуване на карта - цената на картата е 50 лв и 1 лв депозит
- връщане на карта - възстановява се депозитът на притежателя ѝ.

Сноубордистите са конкурентни потребители на системата, които се характеризират с име и всеки от тях има следния "жизнен цикъл":

1. закупува си карта
2. използва я определено време (`Thread.sleep()`)
3. връща я на касата

### Задача 1

Моделирайте обектите `Каса` и `Сноубордист`. Създайте и пуснете конкурентно `N` на брой сноубордисти. След приключване на работния ден (жизнения цикъл на всички сноубордисти), изведете броя карти в наличност и баланса на касата. Подсигурете, че балансът в края на работния ден е коректен (равен на броя продадени карти х 50 лв) и броят на картите в наличност е равен на първоначалния.

### Задача 2

Ако на курорта отидат повече сноубордисти от максималния капацитет на пистите, подсигурете, че при връщане / освобождаване на карта, неуспелите да си закупят карта от първия път ще бъдат автоматично известени.

### Задача 3

Стартирайте сноубордистите чрез thread pool. Подсигурете, че приложението ще приключи своята работа след като последният сноубордист си върне картата.

### Задача 4

Използването само на една каса е крайно неефективно и несъобразено спрямо броя на сноубордистите. Използвайте подходящи синхронизатори и колекции от `java.util.concurrent` пакета, за да имплементирате възможността няколко потребители (например 5) да бъдат обслужвани конкурентно, без да се използва допълнителна синхронизация.
